<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inverted Pendulum | Control Engineering</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="../assets/site.css">
    <style>
        :root {
            --primary: #0f766e;
            --primary-light: #14b8a6;
            --primary-dark: #115e59;
            --surface: #f0fdfa;
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text-main: #334155;
            --text-light: #64748b;
            --border: #e2e8f0;
            --success: #10b981;
            --error: #ef4444;
        }

        [data-theme="dark"] {
            --primary: #2dd4bf;
            --primary-light: #5eead4;
            --primary-dark: #14b8a6;
            --surface: #0f172a;
            --bg: #0f172a;
            --card-bg: #1e293b;
            --text-main: #f1f5f9;
            --text-light: #94a3b8;
            --border: #334155;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg);
            color: var(--text-main);
            margin: 0;

        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
        }

        h1 {
            color: var(--primary);
            font-size: 2.5rem;
            margin: 0;
            font-weight: 700;
        }

        .subtitle {
            color: var(--text-light);
            margin-top: 8px;
        }

        .layout-grid {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 24px;
        }

        @media(max-width: 1100px) {
            .layout-grid {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            border: 1px solid var(--border);
            margin-bottom: 24px;
        }

        .card-header {
            font-weight: 600;
            color: var(--primary);
            font-size: 1.1rem;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--surface);
            padding-bottom: 10px;
        }

        .form-group {
            margin-bottom: 16px;
        }

        label {
            display: block;
            font-size: 0.9rem;
            font-weight: 500;
            margin-bottom: 6px;
        }

        input[type="number"],
        select {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-family: inherit;
            background: var(--card-bg);
            color: var(--text-main);
        }

        input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(15, 118, 110, 0.1);
        }

        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: 0.2s;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
        }

        .btn-sec {
            background: var(--card-bg);
            border: 1px solid var(--border);
            color: var(--text-main);
            margin-top: 10px;
        }

        .btn-sec:hover {
            background: var(--surface);
        }

        .anim-container {
            width: 100%;
            height: 400px;
            background: var(--card-bg);
            border-radius: 8px;
            border: 1px solid var(--border);
            position: relative;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

        .gains-display {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            font-family: 'Courier New', monospace;
            font-weight: 600;
            background: var(--surface);
            padding: 12px;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .gain-val {
            color: var(--primary);
        }

        .status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 6px;
            font-size: 0.9rem;
            display: none;
        }

        .success {
            background: #d1fae5;
            color: #065f46;
        }

        .error {
            background: #fee2e2;
            color: #991b1b;
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            margin-top: 16px;
        }

        .metric-box {
            text-align: center;
            background: var(--surface);
            padding: 10px;
            border-radius: 6px;
            border: 1px solid var(--border);
        }

        .m-val {
            font-weight: 700;
            color: var(--primary);
            font-size: 1.1rem;
        }

        .m-lbl {
            font-size: 0.75rem;
            text-transform: uppercase;
            color: var(--text-light);
            margin-top: 4px;
        }
    </style>
</head>

<body data-page-name="Inverted Pendulum LQR" data-guide="LQR-Guide.md" data-home="../index.html"
    data-tags="LQR, Inverted Pendulum, Cart-Pole, Linear Algebra">

    <div class="container">
        <header>
            <h1 data-i18n="title">Inverted Pendulum Control</h1>
            <p class="subtitle" data-i18n="subtitle">Linear Quadratic Regulator (LQR) on Cart-Pole System</p>
            <p style="margin-top: 10px;"><a href="LQR-Guide.md"
                    style="color: var(--primary); text-decoration: none; font-weight: 500;" data-i18n="readGuide">ðŸ“–
                    Read the Beginner's
                    Guide</a></p>
        </header>

        <div class="layout-grid">
            <!-- Controls -->
            <div>
                <div class="card">
                    <div class="card-header" data-i18n="cardPhysical">Physical Parameters</div>
                    <div class="form-group">
                        <label data-i18n-html="labelCartMass">Cart Mass \( M \) (kg)</label>
                        <input type="number" id="M" value="1.0" step="0.1">
                    </div>
                    <div class="form-group">
                        <label data-i18n-html="labelPendulumMass">Pendulum Mass \( m \) (kg)</label>
                        <input type="number" id="m" value="0.1" step="0.05">
                    </div>
                    <div class="form-group">
                        <label data-i18n-html="labelPendulumLength">Pendulum Length \( l \) (m)</label>
                        <input type="number" id="l" value="1.0" step="0.1">
                    </div>

                    <div class="card-header" style="margin-top: 24px;" data-i18n="cardTuning">LQR Tuning</div>
                    <div class="form-group">
                        <label data-i18n-html="labelQpos">State Cost \( Q_{pos} \) (x)</label>
                        <input type="number" id="Qx" value="1.0">
                    </div>
                    <div class="form-group">
                        <label data-i18n-html="labelQangle">State Cost \( Q_{angle} \) (Î¸)</label>
                        <input type="number" id="Qtheta" value="10.0">
                    </div>
                    <div class="form-group">
                        <label data-i18n-html="labelR">Control Cost \( R \)</label>
                        <input type="number" id="R" value="0.1" step="0.01">
                    </div>

                    <div class="form-group">
                        <label data-i18n="labelInitAngle">Initial Angle (deg)</label>
                        <input type="number" id="initTheta" value="15">
                    </div>

                    <button class="btn btn-primary" onclick="app.updateAndRun()" data-i18n="btnRecalc">Re-Calculate LQR
                        & Reset</button>
                    <div id="statusBox" class="status"></div>
                </div>

                <div class="card">
                    <div class="card-header" data-i18n="cardGains">Computed Feedback Gains</div>
                    <div style="font-size: 0.85rem; color: var(--text-light); margin-bottom: 10px;">
                        <span data-i18n-html="gainsNote">\( u = -K \mathbf{x} \) where \( \mathbf{x} = [x, \dot{x},
                            \theta, \dot{\theta}]^T \)</span>
                    </div>
                    <div class="gains-display">
                        <div>\( K_x \): <span id="kx" class="gain-val">-</span></div>
                        <div>\( K_{\dot{x}} \): <span id="kdx" class="gain-val">-</span></div>
                        <div>\( K_\theta \): <span id="kth" class="gain-val">-</span></div>
                        <div>\( K_{\dot{\theta}} \): <span id="kdth" class="gain-val">-</span></div>
                    </div>
                </div>
            </div>

            <!-- Simulation -->
            <div class="card">
                <div class="card-header" data-i18n="cardSim">Real-Time Simulation</div>
                <div class="anim-container">
                    <canvas id="simCanvas"></canvas>
                </div>

                <div class="metrics">
                    <div class="metric-box">
                        <div class="m-val" id="dispTheta">0Â°</div>
                        <div class="m-lbl" data-i18n="metricAngle">Angle</div>
                    </div>
                    <div class="metric-box">
                        <div class="m-val" id="dispX">0m</div>
                        <div class="m-lbl" data-i18n="metricPosition">Position</div>
                    </div>
                    <div class="metric-box">
                        <div class="m-val" id="dispU">0N</div>
                        <div class="m-lbl" data-i18n="metricForce">Force</div>
                    </div>
                    <div class="metric-box">
                        <div class="m-val" id="dispTime">0s</div>
                        <div class="m-lbl" data-i18n="metricTime">Time</div>
                    </div>
                </div>

                <button class="btn btn-sec" onclick="app.perturb()" data-i18n="btnDisturbance">Add Disturbance (+5N
                    impulse)</button>
            </div>
        </div>
    </div>

    <script>
        window.PAGE_TRANSLATIONS = {
            en: {
                title: "Inverted Pendulum Control",
                subtitle: "Linear Quadratic Regulator (LQR) on Cart-Pole System",
                readGuide: "ðŸ“– Read the Beginner's Guide",
                cardPhysical: "Physical Parameters",
                labelCartMass: "Cart Mass \\( M \\) (kg)",
                labelPendulumMass: "Pendulum Mass \\( m \\) (kg)",
                labelPendulumLength: "Pendulum Length \\( l \\) (m)",
                cardTuning: "LQR Tuning",
                labelQpos: "State Cost \\( Q_{pos} \\) (x)",
                labelQangle: "State Cost \\( Q_{angle} \\) (Î¸)",
                labelR: "Control Cost \\( R \\)",
                labelInitAngle: "Initial Angle (deg)",
                btnRecalc: "Re-Calculate LQR & Reset",
                statusUpdated: "LQR Gains Updated Successfully",
                cardGains: "Computed Feedback Gains",
                gainsNote: "\\( u = -K \\mathbf{x} \\) where \\( \\mathbf{x} = [x, \\dot{x}, \\theta, \\dot{\\theta}]^T \\)",
                cardSim: "Real-Time Simulation",
                metricAngle: "Angle",
                metricPosition: "Position",
                metricForce: "Force",
                metricTime: "Time",
                btnDisturbance: "Add Disturbance (+5N impulse)"
            },
            pl: {
                title: "Sterowanie odwrÃ³conym wahadÅ‚em",
                subtitle: "Regulator LQR (Linear Quadratic Regulator) dla ukÅ‚adu wÃ³zekâ€“wahadÅ‚o",
                readGuide: "ðŸ“– Przeczytaj poradnik dla poczÄ…tkujÄ…cych",
                cardPhysical: "Parametry fizyczne",
                labelCartMass: "Masa wÃ³zka \\( M \\) (kg)",
                labelPendulumMass: "Masa wahadÅ‚a \\( m \\) (kg)",
                labelPendulumLength: "DÅ‚ugoÅ›Ä‡ wahadÅ‚a \\( l \\) (m)",
                cardTuning: "Strojenie LQR",
                labelQpos: "Koszt stanu \\( Q_{pos} \\) (x)",
                labelQangle: "Koszt stanu \\( Q_{angle} \\) (Î¸)",
                labelR: "Koszt sterowania \\( R \\)",
                labelInitAngle: "KÄ…t poczÄ…tkowy (deg)",
                btnRecalc: "Przelicz LQR i zresetuj",
                statusUpdated: "Zaktualizowano wzmocnienia LQR",
                cardGains: "Wyznaczone wzmocnienia sprzÄ™Å¼enia zwrotnego",
                gainsNote: "\\( u = -K \\mathbf{x} \\), gdzie \\( \\mathbf{x} = [x, \\dot{x}, \\theta, \\dot{\\theta}]^T \\)",
                cardSim: "Symulacja w czasie rzeczywistym",
                metricAngle: "KÄ…t",
                metricPosition: "Pozycja",
                metricForce: "SiÅ‚a",
                metricTime: "Czas",
                btnDisturbance: "Dodaj zakÅ‚Ã³cenie (+5N impuls)"
            },
            fr: {
                title: "Commande du pendule inversÃ©",
                subtitle: "RÃ©gulateur LQR (Linear Quadratic Regulator) sur systÃ¨me chariotâ€“pendule",
                readGuide: "ðŸ“– Lire le guide du dÃ©butant",
                cardPhysical: "ParamÃ¨tres physiques",
                labelCartMass: "Masse du chariot \\( M \\) (kg)",
                labelPendulumMass: "Masse du pendule \\( m \\) (kg)",
                labelPendulumLength: "Longueur du pendule \\( l \\) (m)",
                cardTuning: "RÃ©glage LQR",
                labelQpos: "CoÃ»t d'Ã©tat \\( Q_{pos} \\) (x)",
                labelQangle: "CoÃ»t d'Ã©tat \\( Q_{angle} \\) (Î¸)",
                labelR: "CoÃ»t de commande \\( R \\)",
                labelInitAngle: "Angle initial (deg)",
                btnRecalc: "Recalculer le LQR et rÃ©initialiser",
                statusUpdated: "Gains LQR mis Ã  jour",
                cardGains: "Gains de retour calculÃ©s",
                gainsNote: "\\( u = -K \\mathbf{x} \\) oÃ¹ \\( \\mathbf{x} = [x, \\dot{x}, \\theta, \\dot{\\theta}]^T \\)",
                cardSim: "Simulation en temps rÃ©el",
                metricAngle: "Angle",
                metricPosition: "Position",
                metricForce: "Force",
                metricTime: "Temps",
                btnDisturbance: "Ajouter une perturbation (+5N impulsion)"
            },
            es: {
                title: "Control del pÃ©ndulo invertido",
                subtitle: "Regulador LQR (Linear Quadratic Regulator) en sistema carroâ€“pÃ©ndulo",
                readGuide: "ðŸ“– Leer la guÃ­a para principiantes",
                cardPhysical: "ParÃ¡metros fÃ­sicos",
                labelCartMass: "Masa del carro \\( M \\) (kg)",
                labelPendulumMass: "Masa del pÃ©ndulo \\( m \\) (kg)",
                labelPendulumLength: "Longitud del pÃ©ndulo \\( l \\) (m)",
                cardTuning: "Ajuste LQR",
                labelQpos: "Costo de estado \\( Q_{pos} \\) (x)",
                labelQangle: "Costo de estado \\( Q_{angle} \\) (Î¸)",
                labelR: "Costo de control \\( R \\)",
                labelInitAngle: "Ãngulo inicial (deg)",
                btnRecalc: "Recalcular LQR y reiniciar",
                statusUpdated: "Ganancias LQR actualizadas",
                cardGains: "Ganancias de realimentaciÃ³n calculadas",
                gainsNote: "\\( u = -K \\mathbf{x} \\) donde \\( \\mathbf{x} = [x, \\dot{x}, \\theta, \\dot{\\theta}]^T \\)",
                cardSim: "SimulaciÃ³n en tiempo real",
                metricAngle: "Ãngulo",
                metricPosition: "PosiciÃ³n",
                metricForce: "Fuerza",
                metricTime: "Tiempo",
                btnDisturbance: "AÃ±adir perturbaciÃ³n (+5N impulso)"
            },
            pt: {
                title: "Controle do pÃªndulo invertido",
                subtitle: "Regulador LQR (Linear Quadratic Regulator) no sistema carroâ€“pÃªndulo",
                readGuide: "ðŸ“– Ler o guia para iniciantes",
                cardPhysical: "ParÃ¢metros fÃ­sicos",
                labelCartMass: "Massa do carrinho \\( M \\) (kg)",
                labelPendulumMass: "Massa do pÃªndulo \\( m \\) (kg)",
                labelPendulumLength: "Comprimento do pÃªndulo \\( l \\) (m)",
                cardTuning: "Ajuste LQR",
                labelQpos: "Custo de estado \\( Q_{pos} \\) (x)",
                labelQangle: "Custo de estado \\( Q_{angle} \\) (Î¸)",
                labelR: "Custo de controle \\( R \\)",
                labelInitAngle: "Ã‚ngulo inicial (deg)",
                btnRecalc: "Recalcular LQR e redefinir",
                statusUpdated: "Ganhos LQR atualizados",
                cardGains: "Ganhos de realimentaÃ§Ã£o calculados",
                gainsNote: "\\( u = -K \\mathbf{x} \\) onde \\( \\mathbf{x} = [x, \\dot{x}, \\theta, \\dot{\\theta}]^T \\)",
                cardSim: "SimulaÃ§Ã£o em tempo real",
                metricAngle: "Ã‚ngulo",
                metricPosition: "PosiÃ§Ã£o",
                metricForce: "ForÃ§a",
                metricTime: "Tempo",
                btnDisturbance: "Adicionar perturbaÃ§Ã£o (+5N impulso)"
            },
            de: {
                title: "Regelung des inversen Pendels",
                subtitle: "Linear Quadratic Regulator (LQR) fÃ¼r das Cart-Pole-System",
                readGuide: "ðŸ“– Einsteigerleitfaden lesen",
                cardPhysical: "Physikalische Parameter",
                labelCartMass: "Wagenmasse \\( M \\) (kg)",
                labelPendulumMass: "Pendelmasse \\( m \\) (kg)",
                labelPendulumLength: "PendellÃ¤nge \\( l \\) (m)",
                cardTuning: "LQR-Abstimmung",
                labelQpos: "Zustandskosten \\( Q_{pos} \\) (x)",
                labelQangle: "Zustandskosten \\( Q_{angle} \\) (Î¸)",
                labelR: "Stellkosten \\( R \\)",
                labelInitAngle: "Anfangswinkel (deg)",
                btnRecalc: "LQR neu berechnen & zurÃ¼cksetzen",
                statusUpdated: "LQR-VerstÃ¤rkungen aktualisiert",
                cardGains: "Berechnete RÃ¼ckfÃ¼hrverstÃ¤rkungen",
                gainsNote: "\\( u = -K \\mathbf{x} \\) wobei \\( \\mathbf{x} = [x, \\dot{x}, \\theta, \\dot{\\theta}]^T \\)",
                cardSim: "Echtzeitsimulation",
                metricAngle: "Winkel",
                metricPosition: "Position",
                metricForce: "Kraft",
                metricTime: "Zeit",
                btnDisturbance: "StÃ¶rung hinzufÃ¼gen (+5N Impuls)"
            },
            uk: {
                title: "ÐšÐµÑ€ÑƒÐ²Ð°Ð½Ð½Ñ Ð¿ÐµÑ€ÐµÐ²ÐµÑ€Ð½ÑƒÑ‚Ð¸Ð¼ Ð¼Ð°ÑÑ‚Ð½Ð¸ÐºÐ¾Ð¼",
                subtitle: "Ð ÐµÐ³ÑƒÐ»ÑÑ‚Ð¾Ñ€ LQR (Linear Quadratic Regulator) Ð´Ð»Ñ ÑÐ¸ÑÑ‚ÐµÐ¼Ð¸ Ð²Ñ–Ð·Ð¾Ðºâ€“Ð¼Ð°ÑÑ‚Ð½Ð¸Ðº",
                readGuide: "ðŸ“– ÐŸÑ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ñ‚Ð¸ Ð¿Ð¾ÑÑ–Ð±Ð½Ð¸Ðº Ð´Ð»Ñ Ð¿Ð¾Ñ‡Ð°Ñ‚ÐºÑ–Ð²Ñ†Ñ–Ð²",
                cardPhysical: "Ð¤Ñ–Ð·Ð¸Ñ‡Ð½Ñ– Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¸",
                labelCartMass: "ÐœÐ°ÑÐ° Ð²Ñ–Ð·ÐºÐ° \\( M \\) (kg)",
                labelPendulumMass: "ÐœÐ°ÑÐ° Ð¼Ð°ÑÑ‚Ð½Ð¸ÐºÐ° \\( m \\) (kg)",
                labelPendulumLength: "Ð”Ð¾Ð²Ð¶Ð¸Ð½Ð° Ð¼Ð°ÑÑ‚Ð½Ð¸ÐºÐ° \\( l \\) (m)",
                cardTuning: "ÐÐ°Ð»Ð°ÑˆÑ‚ÑƒÐ²Ð°Ð½Ð½Ñ LQR",
                labelQpos: "Ð’Ð°Ñ€Ñ‚Ñ–ÑÑ‚ÑŒ ÑÑ‚Ð°Ð½Ñƒ \\( Q_{pos} \\) (x)",
                labelQangle: "Ð’Ð°Ñ€Ñ‚Ñ–ÑÑ‚ÑŒ ÑÑ‚Ð°Ð½Ñƒ \\( Q_{angle} \\) (Î¸)",
                labelR: "Ð’Ð°Ñ€Ñ‚Ñ–ÑÑ‚ÑŒ ÐºÐµÑ€ÑƒÐ²Ð°Ð½Ð½Ñ \\( R \\)",
                labelInitAngle: "ÐŸÐ¾Ñ‡Ð°Ñ‚ÐºÐ¾Ð²Ð¸Ð¹ ÐºÑƒÑ‚ (deg)",
                btnRecalc: "ÐŸÐµÑ€ÐµÑ€Ð°Ñ…ÑƒÐ²Ð°Ñ‚Ð¸ LQR Ñ– ÑÐºÐ¸Ð½ÑƒÑ‚Ð¸",
                statusUpdated: "ÐŸÑ–Ð´ÑÐ¸Ð»ÐµÐ½Ð½Ñ LQR Ð¾Ð½Ð¾Ð²Ð»ÐµÐ½Ð¾",
                cardGains: "ÐžÐ±Ñ‡Ð¸ÑÐ»ÐµÐ½Ñ– ÐºÐ¾ÐµÑ„Ñ–Ñ†Ñ–Ñ”Ð½Ñ‚Ð¸ Ð·Ð²Ð¾Ñ€Ð¾Ñ‚Ð½Ð¾Ð³Ð¾ Ð·Ð²â€™ÑÐ·ÐºÑƒ",
                gainsNote: "\\( u = -K \\mathbf{x} \\), Ð´Ðµ \\( \\mathbf{x} = [x, \\dot{x}, \\theta, \\dot{\\theta}]^T \\)",
                cardSim: "Ð¡Ð¸Ð¼ÑƒÐ»ÑÑ†Ñ–Ñ Ð² Ñ€ÐµÐ°Ð»ÑŒÐ½Ð¾Ð¼Ñƒ Ñ‡Ð°ÑÑ–",
                metricAngle: "ÐšÑƒÑ‚",
                metricPosition: "ÐŸÐ¾Ð»Ð¾Ð¶ÐµÐ½Ð½Ñ",
                metricForce: "Ð¡Ð¸Ð»Ð°",
                metricTime: "Ð§Ð°Ñ",
                btnDisturbance: "Ð”Ð¾Ð´Ð°Ñ‚Ð¸ Ð·Ð±ÑƒÑ€ÐµÐ½Ð½Ñ (+5N Ñ–Ð¼Ð¿ÑƒÐ»ÑŒÑ)"
            }
        };

        function pageT(key, fallback) {
            const lang = (document.documentElement.getAttribute('lang') || 'en').toLowerCase();
            const dict = window.PAGE_TRANSLATIONS?.[lang] || window.PAGE_TRANSLATIONS?.en || {};
            return (dict && Object.prototype.hasOwnProperty.call(dict, key)) ? dict[key] : fallback;
        }

        const cssVar = (name, fallback = '') => {
            const value = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
            return value || fallback;
        };

        const LA = {
            zeros: (r, c) => Array(r).fill(0).map(() => Array(c).fill(0)),
            eye: (n) => Array(n).fill(0).map((_, i) => Array(n).fill(0).map((_, j) => i === j ? 1 : 0)),

            add: (A, B) => A.map((row, i) => row.map((val, j) => val + B[i][j])),
            sub: (A, B) => A.map((row, i) => row.map((val, j) => val - B[i][j])),

            mul: (A, B) => {
                const r1 = A.length, c1 = A[0].length, r2 = B.length, c2 = B[0].length;
                if (c1 !== r2) throw "Dim error";
                const res = LA.zeros(r1, c2);
                for (let i = 0; i < r1; i++)
                    for (let j = 0; j < c2; j++)
                        for (let k = 0; k < c1; k++)
                            res[i][j] += A[i][k] * B[k][j];
                return res;
            },

            mulS: (A, s) => A.map(row => row.map(v => v * s)), // Scalar mul

            transpose: (A) => A[0].map((_, i) => A.map(row => row[i])),

            inv2x2: (m) => {
                // Only need 1x1 inverse implies R + B'PB is scalar? 
                // B is 4x1, P is 4x4. B'PB is 1x1.
                // Yes, single input system.
                // But let's support general scalar inverse just in case.
                return [[1 / m[0][0]]];
            }
        };

        /**
         * LQR Solver
         */
        class LQRSolver {
            static solve(A, B, Q, R) {
                // Discrete Time LQR Solver via Iteration
                // First discretize continuous A, B to Ad, Bd
                // x_dot = Ax + Bu  =>  x[k+1] = (I + A*dt)x[k] + (B*dt)u[k]
                // Approx Euler Discretization for Solver (needs small dt for accuracy)
                const dt = 0.01;
                const n = 4;

                const Ad = LA.add(LA.eye(n), LA.mulS(A, dt));
                const Bd = LA.mulS(B, dt);

                // Solve Riccati Equation: P = A'PA - A'PB(R + B'PB)^-1 B'PA + Q
                // Iterate P
                let P = Q; // Initialize P with Q
                const maxIter = 1000;
                const tol = 1e-4;

                for (let i = 0; i < maxIter; i++) {
                    const Pd = P;

                    // Term1 = Ad' * P * Ad
                    const T1 = LA.mul(LA.transpose(Ad), LA.mul(P, Ad));

                    // Term2 = (R + Bd' P Bd)^-1
                    const BdT = LA.transpose(Bd);
                    const R_plus_BPB = LA.add(R, LA.mul(BdT, LA.mul(P, Bd)));
                    const InvTerm = LA.inv2x2(R_plus_BPB);

                    // Term3 = Ad' P Bd
                    const T3 = LA.mul(LA.transpose(Ad), LA.mul(P, Bd));

                    // Full second part: T3 * InvTerm * T3'
                    const T2_full = LA.mul(T3, LA.mul(InvTerm, LA.transpose(T3)));

                    const P_new = LA.add(LA.sub(T1, T2_full), Q); // Q is added each step? Yes for discrete algebraic RE iteration P_k+1 = ... + Q

                    // Check convergence
                    let diff = 0;
                    for (let r = 0; r < n; r++) for (let c = 0; c < n; c++) diff += Math.abs(P_new[r][c] - P[r][c]);

                    P = P_new;
                    if (diff < tol) break;
                }

                // Compute K = (R + Bd' P Bd)^-1 Bd' P Ad
                // Note: For Feedback u = -Kx
                const BdT = LA.transpose(Bd);
                const R_plus_BPB = LA.add(R, LA.mul(BdT, LA.mul(P, Bd)));
                const Inv = LA.inv2x2(R_plus_BPB);
                const BPA = LA.mul(BdT, LA.mul(P, Ad));

                const K = LA.mul(Inv, BPA);
                return K[0]; // Return the first row (vector) as it is single input
            }
        }

        /**
         * Diagnostics
         */
        class Diagnostics {
            static run() {
                console.group("Diagnostics");
                // Test LQR solver on scalar system x_dot = -x + u, optimize x^2 + u^2
                // A=[-1], B=[1], Q=[1], R=[1]
                // Discretize: Ad = 0.99, Bd = 0.01
                // Expected K > 0 (stabilizing)
                try {
                    const K = LQRSolver.solve([[-1]], [[1]], [[1]], [[1]]);
                    console.log("Scalar LQR Test K:", K);
                    if (K.length !== 1 || isNaN(K[0])) throw "LQR Solver Failed";
                    console.log("PASS: LQR Solver structural check");
                } catch (e) {
                    console.error(e);
                }
                console.groupEnd();
            }
        }

        /**
         * Main App
         */
        const app = {
            running: false,
            state: [0, 0, 0, 0], // x, x_dot, th, th_dot
            K: [0, 0, 0, 0],

            init: () => {
                Diagnostics.run();
                app.updateAndRun();
                app.loop();
            },

            updateAndRun: () => {
                // Read Params
                const M = parseFloat(document.getElementById('M').value);
                const m = parseFloat(document.getElementById('m').value);
                const l = parseFloat(document.getElementById('l').value);

                const g = 9.81;

                // Define A, B matrices for linearized system (upright)
                // Denominator
                const den = M + m; // Simplification assuming I=0 for point mass m
                // Actually, with point mass m at length l:
                // System matrices (Standard Cart-Pole):
                // x_ddot = (u + m*g*theta*(m/M)) ... no let's use exact linearized form
                // A = [ [0, 1, 0, 0], [0, 0, -m*g/M, 0], [0, 0, 0, 1], [0, 0, (M+m)*g/(M*l), 0] ] -- APPROX?
                // Let's use the rigorous one:
                // A23 = -mg/M (sign depends on definition of theta... usually small angle approx mg*theta is force... )
                // Actually, let's use the standard result:
                // A = [[0,1,0,0], [0,0, -m*g/M, 0], [0,0,0,1], [0,0, (M+m)*g/(M*l), 0]] is common approx for M >> m. 
                // Better:
                // p = M+m, J = m*l*l
                // But for point mass:
                // x_ddot = ... theta_ddot = ...
                // A = 
                // [0, 1, 0, 0]
                // [0, 0, -m*g/M, 0] // Frictionless
                // [0, 0, 0, 1] 
                // [0, 0, (M+m)*g/(M*l), 0]

                // Wait, verifying signs. 
                // If theta>0 (right), gravity pulls it further right (unstable). So acceleration prop to theta should be positive.
                // So A(4,3) should be positive? Yes (M+m)g/Ml > 0.
                // A(2,3) = Force on cart from pendulum? -mg*theta/M (pushes cart left?) Yes.

                const A = [
                    [0, 1, 0, 0],
                    [0, 0, -m * g / M, 0],
                    [0, 0, 0, 1],
                    [0, 0, (M + m) * g / (M * l), 0]
                ];

                const B = [
                    [0],
                    [1 / M],
                    [0],
                    [-1 / (M * l)]
                ];

                // Costs
                const qx = parseFloat(document.getElementById('Qx').value);
                const qt = parseFloat(document.getElementById('Qtheta').value);
                const r_val = parseFloat(document.getElementById('R').value);

                const Q = LA.zeros(4, 4);
                Q[0][0] = qx;
                Q[2][2] = qt;
                // Small penalties on velocities to dampen
                Q[1][1] = 0.01;
                Q[3][3] = 0.01;

                const R = [[r_val]];

                // Solve LQR
                const K_computed = LQRSolver.solve(A, B, Q, R);
                app.K = K_computed;

                // Updates UI
                document.getElementById('kx').textContent = K_computed[0].toFixed(2);
                document.getElementById('kdx').textContent = K_computed[1].toFixed(2);
                document.getElementById('kth').textContent = K_computed[2].toFixed(2);
                document.getElementById('kdth').textContent = K_computed[3].toFixed(2);

                document.getElementById('statusBox').className = "status show success";
                document.getElementById('statusBox').textContent = pageT('statusUpdated', 'LQR Gains Updated Successfully');

                // Reset State
                const initDeg = parseFloat(document.getElementById('initTheta').value);
                app.state = [0, 0, initDeg * Math.PI / 180, 0];
                app.time = 0;
            },

            perturb: () => {
                // Add impulse to x_dot
                app.state[1] += 2.0;
            },

            loop: () => {
                requestAnimationFrame(app.loop);

                const dt = 0.02; // 50Hz sim

                // Physics Step (Nonlinear Dynamics for accuracy)
                const M = parseFloat(document.getElementById('M').value);
                const m = parseFloat(document.getElementById('m').value);
                const l = parseFloat(document.getElementById('l').value);
                const g = 9.81;

                let [x, dx, th, dth] = app.state;

                // Control u = -K*x
                // Note: x state for control is relative to setpoint (0,0,0,0)
                let u = -(app.K[0] * x + app.K[1] * dx + app.K[2] * th + app.K[3] * dth);

                // Clamp force
                u = Math.max(-50, Math.min(50, u));

                // Dynamics
                const s = Math.sin(th);
                const c = Math.cos(th);

                // Equations of motion for Cart-Pole
                // (M+m)x_dd + m*l*th_dd*c - m*l*th_d^2*s = u
                // m*l*x_dd*c + m*l^2*th_dd - m*g*l*s = 0 

                // Solve for accelerations
                // th_dd = (g*s - c*x_dd) / l
                // sub into 1: (M+m)x_dd + m*l/l(g*s - c*x_dd)*c - ... = u
                // (M+m)x_dd + m*g*s*c - m*c^2*x_dd - m*l*th_d^2*s = u
                // x_dd (M + m - m*c^2) = u + m*l*th_d^2*s - m*g*s*c

                const massTerm = M + m - m * c * c;
                const x_dd = (u + m * l * dth * dth * s - m * g * s * c) / massTerm;
                const th_dd = (g * s - c * x_dd) / l;

                // Euler Integration
                dx += x_dd * dt;
                x += dx * dt;

                dth += th_dd * dt;
                th += dth * dt;

                app.state = [x, dx, th, dth];
                app.time += dt;

                // Draw
                app.draw(x, th, u);

                // Metrics
                document.getElementById('dispTheta').textContent = (th * 180 / Math.PI).toFixed(1) + "Â°";
                document.getElementById('dispX').textContent = x.toFixed(2) + "m";
                document.getElementById('dispU').textContent = u.toFixed(1) + "N";
                document.getElementById('dispTime').textContent = app.time.toFixed(1) + "s";
            },

            draw: (x, th, u) => {
                const cvs = document.getElementById('simCanvas');
                const ctx = cvs.getContext('2d');
                const w = cvs.width = cvs.clientWidth;
                const h = cvs.height = cvs.clientHeight;

                ctx.clearRect(0, 0, w, h);

                // Scale
                const scale = 50; // pixels per meter
                const cx = w / 2;
                const cy = h / 2 + 100;

                const cartW = 80;
                const cartH = 40;

                const bx = cx + x * scale;
                const by = cy;

                // Rail
                ctx.strokeStyle = cssVar('--border', '#e2e8f0');
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, cy + cartH / 2);
                ctx.lineTo(w, cy + cartH / 2);
                ctx.stroke();

                // Cart
                ctx.fillStyle = '#0f766e';
                ctx.fillRect(bx - cartW / 2, by - cartH / 2, cartW, cartH);

                // Pendulum
                const l_vis = 150; // Visual length
                const px = bx + l_vis * Math.sin(th);
                const py = by - l_vis * Math.cos(th);

                ctx.strokeStyle = '#334155';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(bx, by);
                ctx.lineTo(px, py);
                ctx.stroke();

                // Bob
                ctx.fillStyle = '#ef4444';
                ctx.beginPath();
                ctx.arc(px, py, 10, 0, Math.PI * 2);
                ctx.fill();

                // Force Arrow
                if (Math.abs(u) > 1) {
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 3;
                    const dir = Math.sign(u);
                    const len = Math.min(Math.abs(u) * 2, 60);
                    const as = bx - (dir * cartW / 2);

                    ctx.beginPath();
                    ctx.moveTo(as, by);
                    ctx.lineTo(as + dir * len, by);
                    ctx.stroke();
                }
            }
        };

        window.PAGE_I18N_ONCHANGE = () => {
            const sb = document.getElementById('statusBox');
            if (sb && sb.className.includes('show')) {
                sb.textContent = pageT('statusUpdated', 'LQR Gains Updated Successfully');
            }
        };

        window.onload = app.init;
    </script>
    <script src="../assets/site.js"></script>
</body>

</html>