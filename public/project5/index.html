<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Autonomous Path Tracking | Project 5</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="../assets/site.css">
    <style>
        :root {
            --primary: #3b82f6;
            --dark: #0f172a;
            --surf: #f1f5f9;
            --card: #ffffff;
            --muted: #64748b;
            --border: #cbd5e1;
            --btn-hover: #2563eb;
        }

        [data-theme="dark"] {
            --dark: #f1f5f9;
            --surf: #0f172a;
            --card: #1e293b;
            --muted: #94a3b8;
            --border: #334155;
            --btn-hover: #60a5fa;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--surf);
            color: var(--dark);
            margin: 0;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
        }

        .header {
            grid-column: 1/-1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        h1 {
            margin: 0;
            color: var(--primary);
        }

        .card {
            background: var(--card);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
        }

        /* Controls */
        .control-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        select,
        input {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border);
            border-radius: 6px;
            margin-bottom: 10px;
            background: var(--card);
            color: var(--dark);
        }

        .btn {
            width: 100%;
            padding: 12px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: 0.2s;
        }

        .btn:hover {
            background: var(--btn-hover);
        }

        .kpi-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 10px;
            background: var(--surf);
            border-radius: 8px;
        }

        .kpi-val {
            font-weight: 700;
            color: var(--primary);
            font-family: monospace;
        }

        /* Vis */
        canvas#simCanvas {
            width: 100%;
            height: 500px;
            background: #1e293b;
            border-radius: 8px;
            cursor: crosshair;
        }

        /* Charts */
        .chart-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
            height: 180px;
        }

        .mini-chart {
            background: var(--card);
            padding: 10px;
            border-radius: 8px;
            position: relative;
        }
    </style>
</head>

<body data-page-name="Autonomous Path Tracking" data-guide="Path-Tracking-Guide.md" data-home="../index.html"
    data-tags="MPC, Stanley, Path Tracking, Autonomous Vehicles, Simulation">
    <div class="container">
        <div class="header">
            <div>
                <h1 data-i18n="title">Autonomous Path Tracking</h1>
                <p style="margin: 5px 0 0; color: var(--muted);" data-i18n="subtitle">Stanley Controller vs Model
                    Predictive Control (MPC)</p>
            </div>
            <a href="Path-Tracking-Guide.md" style="color: var(--primary); font-weight: 600; text-decoration: none;"
                data-i18n="readGuide">ðŸ“–
                Read Guide</a>
        </div>

        <!-- Sidebar -->
        <div class="card">
            <div class="control-panel">
                <div class="control-group">
                    <label data-i18n="labelScenario">Scenario</label>
                    <select id="scenarioType" onchange="sim.reset()">
                        <option value="ideal" data-i18n-option="scenIdeal">Ideal Conditions</option>
                        <option value="wind" data-i18n-option="scenWind">Strong Crosswind</option>
                        <option value="ice" data-i18n-option="scenIce">Icy Road (Lag)</option>
                        <option value="noise" data-i18n-option="scenNoise">Sensor Noise</option>
                    </select>
                </div>

                <div class="control-group">
                    <label data-i18n="labelArchitecture">Controller Architecture</label>
                    <select id="ctrlType" onchange="sim.reset()">
                        <option value="stanley" data-i18n-option="optionStanley">Stanley (Geometric)</option>
                        <option value="mpc" data-i18n-option="optionMpc">MPC (Sampling-based)</option>
                    </select>
                </div>
            </div>

            <div class="control-group">
                <label data-i18n="labelSpeed">Simulation Speed</label>
                <input type="range" id="speed" min="5" max="30" value="15"
                    oninput="document.getElementById('spdVal').innerText=this.value+' m/s'">
                <div style="text-align: right; font-size: 0.8em; color: var(--muted);" id="spdVal">15 m/s</div>
            </div>

            <div id="stanleyParams">
                <label data-i18n="labelGainK">Gain (k)</label>
                <input type="number" id="st_k" value="2.5" step="0.1">
            </div>

            <div id="mpcParams" style="display:none">
                <label data-i18n="labelHorizonN">Prediction Horizon (N)</label>
                <input type="number" id="mpc_N" value="25">
                <label data-i18n="labelCostR">Steering Cost (R)</label>
                <input type="number" id="mpc_R" value="0.5" step="0.1">
            </div>

            <div class="kpi-row">
                <span data-i18n="kpiCte">CTE:</span> <span id="cte" class="kpi-val">0.00 m</span>
            </div>
            <div class="kpi-row">
                <span data-i18n="kpiHeadingErr">Heading Err:</span> <span id="he" class="kpi-val">0.00 rad</span>
            </div>

            <button class="btn" onclick="sim.reset()" data-i18n="btnNewTrack">Simulate New Track</button>
            <div style="margin-top: 20px; font-size: 0.8em; font-style: italic; color: #94a3b8;" data-i18n="hintPause">
                Click on canvas to pause/resume.
            </div>
        </div>

        <!-- Main View -->
        <div>
            <div class="card" style="padding: 0; overflow: hidden;">
                <canvas id="simCanvas"></canvas>
            </div>

            <div class="chart-panel">
                <div class="mini-chart">
                    <canvas id="chartCTE"></canvas>
                </div>
                <div class="mini-chart">
                    <canvas id="chartSteer"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        window.PAGE_TRANSLATIONS = {
            en: {
                title: "Autonomous Path Tracking",
                subtitle: "Stanley Controller vs Model Predictive Control (MPC)",
                readGuide: "ðŸ“– Read Guide",
                labelScenario: "Scenario",
                scenIdeal: "Ideal Conditions",
                scenWind: "Strong Crosswind",
                scenIce: "Icy Road (Lag)",
                scenNoise: "Sensor Noise",
                labelArchitecture: "Controller Architecture",
                optionStanley: "Stanley (Geometric)",
                optionMpc: "MPC (Sampling-based)",
                labelSpeed: "Simulation Speed",
                labelGainK: "Gain (k)",
                labelHorizonN: "Prediction Horizon (N)",
                labelCostR: "Steering Cost (R)",
                kpiCte: "CTE:",
                kpiHeadingErr: "Heading Err:",
                btnNewTrack: "Simulate New Track",
                hintPause: "Click on canvas to pause/resume.",
                chartCte: "Cross Track Error (m)",
                chartSteer: "Steering Angle (rad)"
            },
            pl: {
                title: "Åšledzenie trajektorii (autonomiczne)",
                subtitle: "Regulator Stanley vs sterowanie predykcyjne (MPC)",
                readGuide: "ðŸ“– Czytaj poradnik",
                labelArchitecture: "Architektura regulatora",
                optionStanley: "Stanley (geometryczny)",
                optionMpc: "MPC (prÃ³bkowane)",
                labelSpeed: "PrÄ™dkoÅ›Ä‡ symulacji",
                labelGainK: "Wzmocnienie (k)",
                labelHorizonN: "Horyzont predykcji (N)",
                labelCostR: "Koszt skrÄ™tu (R)",
                kpiCte: "CTE:",
                kpiHeadingErr: "BÅ‚Ä…d kursu:",
                btnNewTrack: "Wygeneruj nowy tor",
                hintPause: "Kliknij na pÅ‚Ã³tno, aby wstrzymaÄ‡/wznowiÄ‡.",
                chartCte: "BÅ‚Ä…d poprzeczny (m)",
                chartSteer: "KÄ…t skrÄ™tu (rad)"
            },
            fr: {
                title: "Suivi de trajectoire autonome",
                subtitle: "ContrÃ´leur Stanley vs commande prÃ©dictive (MPC)",
                readGuide: "ðŸ“– Lire le guide",
                labelArchitecture: "Architecture du contrÃ´leur",
                optionStanley: "Stanley (gÃ©omÃ©trique)",
                optionMpc: "MPC (Ã©chantillonnage)",
                labelSpeed: "Vitesse de simulation",
                labelGainK: "Gain (k)",
                labelHorizonN: "Horizon de prÃ©diction (N)",
                labelCostR: "CoÃ»t de braquage (R)",
                kpiCte: "CTE :",
                kpiHeadingErr: "Erreur de cap :",
                btnNewTrack: "Simuler une nouvelle piste",
                hintPause: "Cliquez sur le canevas pour pause/reprise.",
                chartCte: "Erreur de trajectoire (m)",
                chartSteer: "Angle de braquage (rad)"
            },
            es: {
                title: "Seguimiento de trayectoria autÃ³nomo",
                subtitle: "Controlador Stanley vs control predictivo (MPC)",
                readGuide: "ðŸ“– Leer guÃ­a",
                labelArchitecture: "Arquitectura del controlador",
                optionStanley: "Stanley (geomÃ©trico)",
                optionMpc: "MPC (muestreo)",
                labelSpeed: "Velocidad de simulaciÃ³n",
                labelGainK: "Ganancia (k)",
                labelHorizonN: "Horizonte de predicciÃ³n (N)",
                labelCostR: "Costo de giro (R)",
                kpiCte: "CTE:",
                kpiHeadingErr: "Error de rumbo:",
                btnNewTrack: "Simular nueva pista",
                hintPause: "Haz clic en el lienzo para pausar/reanudar.",
                chartCte: "Error lateral (m)",
                chartSteer: "Ãngulo de direcciÃ³n (rad)"
            },
            pt: {
                title: "Rastreamento autÃ´nomo de trajetÃ³ria",
                subtitle: "Controlador Stanley vs controle preditivo (MPC)",
                readGuide: "ðŸ“– Ler guia",
                labelArchitecture: "Arquitetura do controlador",
                optionStanley: "Stanley (geomÃ©trico)",
                optionMpc: "MPC (amostragem)",
                labelSpeed: "Velocidade de simulaÃ§Ã£o",
                labelGainK: "Ganho (k)",
                labelHorizonN: "Horizonte de prediÃ§Ã£o (N)",
                labelCostR: "Custo de esterÃ§amento (R)",
                kpiCte: "CTE:",
                kpiHeadingErr: "Erro de rumo:",
                btnNewTrack: "Simular nova pista",
                hintPause: "Clique no canvas para pausar/continuar.",
                chartCte: "Erro lateral (m)",
                chartSteer: "Ã‚ngulo de direÃ§Ã£o (rad)"
            },
            de: {
                title: "Autonomes Pfad-Tracking",
                subtitle: "Stanley-Regler vs Model Predictive Control (MPC)",
                readGuide: "ðŸ“– Leitfaden lesen",
                labelArchitecture: "Reglerarchitektur",
                optionStanley: "Stanley (geometrisch)",
                optionMpc: "MPC (Sampling-basiert)",
                labelSpeed: "Simulationsgeschwindigkeit",
                labelGainK: "VerstÃ¤rkung (k)",
                labelHorizonN: "PrÃ¤diktionshorizont (N)",
                labelCostR: "Lenkkosten (R)",
                kpiCte: "CTE:",
                kpiHeadingErr: "Kursfehler:",
                btnNewTrack: "Neue Strecke simulieren",
                hintPause: "Klicken Sie auf die ZeichenflÃ¤che zum Pausieren/Fortsetzen.",
                chartCte: "Querabweichung (m)",
                chartSteer: "Lenkwinkel (rad)"
            },
            uk: {
                title: "ÐÐ²Ñ‚Ð¾Ð½Ð¾Ð¼Ð½Ðµ Ð²Ñ–Ð´ÑÑ‚ÐµÐ¶ÐµÐ½Ð½Ñ Ñ‚Ñ€Ð°Ñ”ÐºÑ‚Ð¾Ñ€Ñ–Ñ—",
                subtitle: "Ð ÐµÐ³ÑƒÐ»ÑÑ‚Ð¾Ñ€ Stanley vs Ð¿Ñ€ÐµÐ´Ð¸ÐºÑ‚Ð¸Ð²Ð½Ðµ ÐºÐµÑ€ÑƒÐ²Ð°Ð½Ð½Ñ (MPC)",
                readGuide: "ðŸ“– Ð§Ð¸Ñ‚Ð°Ñ‚Ð¸ Ð¿Ð¾ÑÑ–Ð±Ð½Ð¸Ðº",
                labelArchitecture: "ÐÑ€Ñ…Ñ–Ñ‚ÐµÐºÑ‚ÑƒÑ€Ð° Ñ€ÐµÐ³ÑƒÐ»ÑÑ‚Ð¾Ñ€Ð°",
                optionStanley: "Stanley (Ð³ÐµÐ¾Ð¼ÐµÑ‚Ñ€Ð¸Ñ‡Ð½Ð¸Ð¹)",
                optionMpc: "MPC (Ð²Ð¸Ð±Ñ–Ñ€ÐºÐ°)",
                labelSpeed: "Ð¨Ð²Ð¸Ð´ÐºÑ–ÑÑ‚ÑŒ ÑÐ¸Ð¼ÑƒÐ»ÑÑ†Ñ–Ñ—",
                labelGainK: "ÐŸÑ–Ð´ÑÐ¸Ð»ÐµÐ½Ð½Ñ (k)",
                labelHorizonN: "Ð“Ð¾Ñ€Ð¸Ð·Ð¾Ð½Ñ‚ Ð¿Ñ€Ð¾Ð³Ð½Ð¾Ð·Ñƒ (N)",
                labelCostR: "Ð’Ð°Ñ€Ñ‚Ñ–ÑÑ‚ÑŒ ÐºÐµÑ€Ð¼Ð° (R)",
                kpiCte: "CTE:",
                kpiHeadingErr: "ÐŸÐ¾Ð¼Ð¸Ð»ÐºÐ° ÐºÑƒÑ€ÑÑƒ:",
                btnNewTrack: "Ð—Ð³ÐµÐ½ÐµÑ€ÑƒÐ²Ð°Ñ‚Ð¸ Ð½Ð¾Ð²Ñƒ Ñ‚Ñ€Ð°ÑÑƒ",
                hintPause: "ÐšÐ»Ð°Ñ†Ð½Ñ–Ñ‚ÑŒ Ð½Ð° Ð¿Ð¾Ð»Ð¾Ñ‚Ð½Ñ–, Ñ‰Ð¾Ð± Ð¿Ð°ÑƒÐ·Ð°/Ð¿Ñ€Ð¾Ð´Ð¾Ð²Ð¶ÐµÐ½Ð½Ñ.",
                chartCte: "ÐŸÐ¾Ð¿ÐµÑ€ÐµÑ‡Ð½Ð° Ð¿Ð¾Ñ…Ð¸Ð±ÐºÐ° (m)",
                chartSteer: "ÐšÑƒÑ‚ ÐºÐµÑ€Ð¼Ð° (rad)"
            }
        };

        function pageT(key, fallback) {
            const lang = (document.documentElement.getAttribute('lang') || 'en').toLowerCase();
            const dict = window.PAGE_TRANSLATIONS?.[lang] || window.PAGE_TRANSLATIONS?.en || {};
            return (dict && Object.prototype.hasOwnProperty.call(dict, key)) ? dict[key] : fallback;
        }

        // --- Utils ---
        const dist = (p1, p2) => Math.hypot(p1.x - p2.x, p1.y - p2.y);

        // --- Charting ---
        const MAX_POINTS = 100;
        const chartConfig = (label, color, min, max) => ({
            type: 'line',
            data: { labels: Array(MAX_POINTS).fill(''), datasets: [{ label, data: Array(MAX_POINTS).fill(null), borderColor: color, borderWidth: 2, pointRadius: 0, tension: 0.4 }] },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                scales: {
                    y: { min, max, grid: { color: '#f1f5f9' } },
                    x: { display: false }
                },
                plugins: { legend: { display: true, labels: { font: { size: 10 } } } }
            }
        });

        let chartCTE, chartSteer;

        // --- Sim Engine ---
        class Track {
            constructor() {
                this.generate();
            }
            generate() {
                this.points = [];
                // Procedural Track: Perlin-ish noise
                let y = 0;
                let dy = 0;
                for (let x = 0; x < 500; x += 2) {
                    // Curvature changes slowly
                    dy += (Math.random() - 0.5) * 0.5;
                    dy = Math.max(-2, Math.min(2, dy)); // Clamp derivative
                    y += dy;

                    // Add sine wave component for regularity
                    const sine = 40 * Math.sin(x * 0.02);

                    this.points.push({ x: x, y: y + sine });
                }
            }
            getNearest(pos) {
                let minD = Infinity;
                let idx = 0;
                // Optimization: Local search
                for (let i = 0; i < this.points.length; i++) {
                    const d = dist(pos, this.points[i]);
                    if (d < minD) { minD = d; idx = i; }
                }
                return { idx, point: this.points[idx], dist: minD };
            }
        }

        const sim = {
            car: { x: 0, y: 0, yaw: 0, v: 15, L: 2.5, steerActual: 0 },
            track: null,
            paused: false,
            scenario: 'ideal', // ideal, wind, ice, noise

            init: () => {
                // Init Charts
                const ctxCTE = document.getElementById('chartCTE').getContext('2d');
                chartCTE = new Chart(ctxCTE, chartConfig(pageT('chartCte', 'Cross Track Error (m)'), '#ef4444', -5, 5));

                const ctxStr = document.getElementById('chartSteer').getContext('2d');
                chartSteer = new Chart(ctxStr, chartConfig(pageT('chartSteer', 'Steering Angle (rad)'), '#3b82f6', -1, 1));

                // Canvas Click
                document.getElementById('simCanvas').addEventListener('click', () => sim.paused = !sim.paused);

                sim.reset();
                sim.loop();
            },

            reset: () => {
                sim.track = new Track();
                sim.car.x = 0;
                sim.car.y = 0;
                sim.car.yaw = 0.5;
                sim.car.steerActual = 0;
                sim.scenario = document.getElementById('scenarioType').value;

                // Clear Charts
                chartCTE.data.datasets[0].data.fill(null);
                chartSteer.data.datasets[0].data.fill(null);

                // UI
                const type = document.getElementById('ctrlType').value;
                document.getElementById('stanleyParams').style.display = type === 'stanley' ? 'block' : 'none';
                document.getElementById('mpcParams').style.display = type === 'mpc' ? 'block' : 'none';
            },

            updateCharts: (cte, steer) => {
                const addData = (chart, val) => {
                    const data = chart.data.datasets[0].data;
                    data.shift();
                    data.push(val);
                    chart.update(); // Note: Update every frame might be heavy, but fine for 60fps on modern machines
                };
                addData(chartCTE, cte);
                addData(chartSteer, steer);
            },

            loop: () => {
                requestAnimationFrame(sim.loop);
                if (sim.paused) return;

                const dt = 0.05;
                const type = document.getElementById('ctrlType').value;
                sim.car.v = parseFloat(document.getElementById('speed').value);
                sim.scenario = document.getElementById('scenarioType').value;

                // Control
                let steerTarget = 0;
                let debug = [];
                const nearest = sim.track.getNearest(sim.car);

                // Calculate CTE (signed)
                const next = sim.track.points[Math.min(nearest.idx + 1, sim.track.points.length - 1)];
                const pathYaw = Math.atan2(next.y - nearest.point.y, next.x - nearest.point.x);
                const ry = sim.car.y - nearest.point.y;
                const rx = sim.car.x - nearest.point.x;
                // Sign: Cross product z
                const cp = (next.x - nearest.point.x) * ry - (next.y - nearest.point.y) * rx;
                let cte = Math.abs(nearest.dist) * (cp > 0 ? 1 : -1);

                // SCENARIO: Noise
                // Add noise to sensor readings (CTE and Heading)
                if (sim.scenario === 'noise') {
                    cte += (Math.random() - 0.5) * 1.5; // Jittery CTE
                }

                // Helper: Heading Err
                let he = pathYaw - sim.car.yaw;
                while (he > Math.PI) he -= 2 * Math.PI;
                while (he < -Math.PI) he += 2 * Math.PI;

                if (type === 'stanley') {
                    // Stanley
                    const k = parseFloat(document.getElementById('st_k').value);
                    const delta = Math.atan2(-k * cte, sim.car.v + 1);
                    steerTarget = he + delta;
                } else {
                    // MPC (Sampling)
                    const N = parseInt(document.getElementById('mpc_N').value);
                    const R = parseFloat(document.getElementById('mpc_R').value);
                    const samples = 40;
                    let bestCost = Infinity;

                    // Simple 0th order optimization (Constant Turn)
                    for (let i = 0; i < samples; i++) {
                        const s = -0.6 + (1.2 * i / samples);
                        let tx = sim.car.x, ty = sim.car.y, tyaw = sim.car.yaw;
                        let cost = 0;
                        const trace = [];

                        for (let t = 0; t < N; t++) {
                            tx += sim.car.v * Math.cos(tyaw) * dt;
                            ty += sim.car.v * Math.sin(tyaw) * dt;
                            tyaw += (sim.car.v / sim.car.L) * Math.tan(s) * dt;
                            trace.push({ x: tx, y: ty });

                            // Distance cost
                            const n = sim.track.getNearest({ x: tx, y: ty });
                            cost += n.dist * n.dist;
                        }
                        // Input Cost
                        cost += s * s * R * 10;

                        if (cost < bestCost) {
                            bestCost = cost;
                            steerTarget = s;
                        }
                        if (i % 3 === 0) debug.push({ path: trace, cost: cost });
                    }
                }

                // SCENARIO: Ice (Lag)
                // Smooth towards target instead of instant snap
                if (sim.scenario === 'ice') {
                    const alpha = 0.05; // Very slow response
                    sim.car.steerActual += (steerTarget - sim.car.steerActual) * alpha;
                } else {
                    // Normal car has *some* lag, but mostly responsive
                    const alpha = 0.5;
                    sim.car.steerActual += (steerTarget - sim.car.steerActual) * alpha;
                }

                // Clamp
                sim.car.steerActual = Math.max(-0.6, Math.min(0.6, sim.car.steerActual));

                // SCENARIO: Wind (Drift)
                // Add lateral force
                if (sim.scenario === 'wind') {
                    // Constant push in Y + random gusts
                    const windForce = 0.2 + (Math.random() * 0.1);
                    sim.car.y += windForce; // Direct position drift (simplified physics)
                    // Or yaw drift?
                    sim.car.yaw += 0.02 * dt;
                }

                // Physics
                sim.car.x += sim.car.v * Math.cos(sim.car.yaw) * dt;
                sim.car.y += sim.car.v * Math.sin(sim.car.yaw) * dt;
                sim.car.yaw += (sim.car.v / sim.car.L) * Math.tan(sim.car.steerActual) * dt;

                // UI Pushes
                document.getElementById('cte').innerText = cte.toFixed(2) + " m";
                document.getElementById('he').innerText = he.toFixed(2) + " rad";
                sim.updateCharts(cte, sim.car.steerActual);

                // Reset Check
                if (sim.car.x > sim.track.points[sim.track.points.length - 1].x) sim.reset();

                // Draw
                sim.draw(debug, sim.car.steerActual);
            },

            draw: (debug, steerActual) => {
                const cvs = document.getElementById('simCanvas');
                const ctx = cvs.getContext('2d');
                cvs.width = cvs.clientWidth;
                cvs.height = cvs.clientHeight;

                // Camera
                const camX = sim.car.x * 10 - 200;
                const camY = sim.car.y * 10 - 250;

                ctx.save();
                ctx.translate(-camX, -camY);
                // Scale implies 10px = 1m
                const SCALE = 10;

                // 1. Draw Asphalt
                ctx.strokeStyle = '#334155';
                ctx.lineWidth = 8 * SCALE; // 8m wide road
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                sim.track.points.forEach((p, i) => {
                    if (i === 0) ctx.moveTo(p.x * SCALE, p.y * SCALE);
                    else ctx.lineTo(p.x * SCALE, p.y * SCALE);
                });
                ctx.stroke();

                // 2. Centerline
                ctx.strokeStyle = '#cbd5e1';
                ctx.lineWidth = 0.2 * SCALE;
                ctx.setLineDash([2 * SCALE, 2 * SCALE]);
                ctx.stroke();
                ctx.setLineDash([]);

                // 3. MPC Debug
                if (debug) {
                    debug.forEach(d => {
                        // Opacity based on cost (Lower cost = Brighter)
                        // This is tricky, just fixed faint green
                        ctx.strokeStyle = 'rgba(74, 222, 128, 0.1)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        d.path.forEach((p, i) => {
                            if (i === 0) ctx.moveTo(p.x * SCALE, p.y * SCALE);
                            else ctx.lineTo(p.x * SCALE, p.y * SCALE);
                        });
                        ctx.stroke();
                    });
                }

                // 4. Car
                ctx.translate(sim.car.x * SCALE, sim.car.y * SCALE);
                ctx.rotate(sim.car.yaw);

                // Body
                ctx.fillStyle = '#3b82f6';
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 10;
                ctx.fillRect(-1.5 * SCALE, -0.8 * SCALE, 3 * SCALE, 1.6 * SCALE);
                ctx.shadowBlur = 0;

                // Wheels (Ackermann)
                ctx.fillStyle = '#1e293b';
                const wL = 0.6 * SCALE;
                const wW = 0.3 * SCALE;

                // Rear (Fixed)
                ctx.fillRect(-1.5 * SCALE, -0.9 * SCALE, wL, wW); // RL
                ctx.fillRect(-1.5 * SCALE, 0.6 * SCALE, wL, wW); // RR

                // Front (Steered)
                ctx.save();
                ctx.translate(1.2 * SCALE, -0.9 * SCALE); // FL
                ctx.rotate(steer);
                ctx.fillRect(-wL / 2, -wW / 2, wL, wW);
                ctx.restore();

                ctx.save();
                ctx.translate(1.2 * SCALE, 0.7 * SCALE); // FR
                ctx.rotate(steer);
                ctx.fillRect(-wL / 2, -wW / 2, wL, wW);
                ctx.restore();

                ctx.restore();
            }
        };

        window.PAGE_I18N_ONCHANGE = () => {
            if (chartCTE) {
                chartCTE.data.datasets[0].label = pageT('chartCte', 'Cross Track Error (m)');
                chartCTE.update();
            }
            if (chartSteer) {
                chartSteer.data.datasets[0].label = pageT('chartSteer', 'Steering Angle (rad)');
                chartSteer.update();
            }
        };

        window.onload = sim.init;
    </script>
    <script src="../assets/site.js"></script>
</body>

</html>