<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sliding Mode Control | Control Engineering</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="../assets/site.css">
</head>

<body data-page-name="Sliding Mode Control" data-guide="SMC-Guide.md" data-home="../index.html"
    data-tags="SMC, Robust, Nonlinear, Phase Plane">

    <div class="lab-shell">
        <header class="hero lab-card soft">
            <div>
                <h1 data-i18n="title">Sliding Mode Control</h1>
                <p data-i18n="subtitle">Visualize the "Reaching" and "Sliding" phases on the phase plane. Robust control
                    in action.</p>
                <div style="margin-top: 12px;">
                    <a class="pill ghost" href="SMC-Guide.md" data-i18n="readGuide">üìñ Read Guide</a>
                </div>
            </div>
        </header>

        <div class="lab-grid" style="grid-template-columns: 350px 1fr;">
            <!-- Configuration -->
            <div class="lab-card">
                <h3 data-i18n="config">Configuration</h3>

                <div style="margin-bottom: 20px;">
                    <label style="display:block; margin-bottom:8px;">
                        <span data-i18n="gainK">Switching Gain (K)</span>
                        <span id="valK"
                            style="float:right; font-family:monospace; color:var(--primary-light);">5.0</span>
                    </label>
                    <input type="range" id="sliderK" min="0.1" max="20" step="0.1" value="5.0" style="width:100%">
                </div>

                <div style="margin-bottom: 20px;">
                    <label style="display:block; margin-bottom:8px;">
                        <span data-i18n="slopeLambda">Surface Slope (Œª)</span>
                        <span id="valLambda"
                            style="float:right; font-family:monospace; color:var(--primary-light);">1.0</span>
                    </label>
                    <input type="range" id="sliderLambda" min="0.1" max="5" step="0.1" value="1.0" style="width:100%">
                    <small style="color:var(--text-light);" data-i18n="slopeDesc">Determines speed of convergence in
                        sliding phase.</small>
                </div>

                <div
                    style="margin-top: 24px; padding: 16px; background: var(--surface); border-radius: 8px; border: 1px solid var(--border);">
                    <h4 style="margin:0 0 12px 0;">Metrics</h4>
                    <div style="display:flex; justify-content:space-between; margin-bottom:8px;">
                        <span>Error (e):</span>
                        <span id="metricE" style="font-family:monospace; font-weight:bold;">0.00</span>
                    </div>
                    <div style="display:flex; justify-content:space-between; margin-bottom:8px;">
                        <span>Error Dot (ƒó):</span>
                        <span id="metricEdot" style="font-family:monospace; font-weight:bold;">0.00</span>
                    </div>
                    <div style="display:flex; justify-content:space-between;">
                        <span>Surface (s):</span>
                        <span id="metricS"
                            style="font-family:monospace; font-weight:bold; color:var(--accent);">0.00</span>
                    </div>
                </div>

                <button class="btn" onclick="resetSim()" style="margin-top: 20px; width:100%;" data-i18n="reset">Reset
                    Simulation</button>
            </div>

            <!-- Visualization -->
            <div class="lab-card">
                <h3 data-i18n="viz">Phase Plane (Error vs Error Rate)</h3>
                <div style="height: 500px; width: 100%;">
                    <canvas id="smcChart"></canvas>
                </div>
                <div style="margin-top: 10px; text-align: center; color: var(--text-light); font-size: 0.9rem;">
                    <span style="color: #60a5fa; border-bottom: 2px solid #60a5fa;">‚ñ¨ Sliding Surface</span> |
                    <span style="color: #ef4444;">‚óè State Trajectory</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Glossary & Site Scripts -->
    <script src="../assets/glossary.js"></script>
    <script src="../assets/site.js"></script>

    <script>
        window.PAGE_TRANSLATIONS = {
            en: {
                title: 'Sliding Mode Control',
                subtitle: 'Visualize the "Reaching" and "Sliding" phases on the phase plane.',
                readGuide: 'üìñ Read Guide',
                config: 'Configuration',
                gainK: 'Switching Gain (K)',
                slopeLambda: 'Surface Slope (Œª)',
                slopeDesc: 'Steeper = Faster but needs more gain.',
                viz: 'Phase Plane (Error vs Error Rate)',
                reset: 'Reset Simulation'
            },
            pl: {
                title: 'Sterowanie ≈ölizgowe (SMC)',
                subtitle: 'Wizualizacja fazy "doj≈õcia" i "≈õlizgu" na p≈Çaszczy≈∫nie fazowej.',
                readGuide: 'üìñ Przeczytaj poradnik',
                config: 'Konfiguracja',
                gainK: 'Wzmocnienie prze≈ÇƒÖcze≈Ñ (K)',
                slopeLambda: 'Nachylenie powierzchni (Œª)',
                slopeDesc: 'Stromiej = Szybciej, ale wymaga wiƒôkszego K.',
                viz: 'P≈Çaszczyzna fazowa',
                reset: 'Resetuj symulacjƒô'
            }
        };

        // --- SMC Logic ---
        // Plant: Double Integrator (Simplest mechanical system F=ma)
        // x1 = position, x2 = velocity
        // u = force
        // Target: x = 0 (Stabilization)
        // Error e = 0 - x = -x
        // Error dot = -v

        const SMC = {
            e: 5,
            edot: 0,
            K: 5.0,
            lambda: 1.0,

            update: function (dt) {
                // Surface s = edot + lambda * e
                const s = this.edot + this.lambda * this.e;

                // Control Law: u = K * sign(s) (Ideally)
                // In terms of plant dynamics (assuming mass = 1):
                // x_ddot = u
                // e_ddot = -x_ddot = -u
                // So e_ddot = -K * sign(s)

                // Let's add some disturbance or imperfect plant to make it interesting
                // e_ddot = -u + disturbance

                // Discrete simulation
                // Simple Euler integration

                const u = this.K * Math.sign(s);
                const disturbance = Math.sin(Date.now() / 1000) * 1.0; // Small low freq disturbance

                // e_ddot = -u
                // Let's model the plant response slightly dampened
                const e_ddot = -u + disturbance;

                this.edot += e_ddot * dt;
                this.e += this.edot * dt;

                return { s };
            }
        };

        // --- Visualization ---
        let chart = null;
        let timer = null;
        const trajData = []; // History of (e, edot)

        function initChart() {
            const ctx = document.getElementById('smcChart').getContext('2d');
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            const gridColor = isDark ? '#334155' : '#e2e8f0';

            // Generate Sliding Line points based on current lambda
            // s = edot + lambda*e = 0 => edot = -lambda*e
            const lineData = genLineData(SMC.lambda);

            chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: 'Sliding Surface',
                            data: lineData,
                            showLine: true,
                            borderColor: '#60a5fa',
                            pointRadius: 0,
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        {
                            label: 'Trajectory',
                            data: trajData,
                            showLine: true,
                            borderColor: '#ef4444',
                            backgroundColor: '#ef4444',
                            pointRadius: 1,
                            borderWidth: 2
                        },
                        {
                            label: 'Current State',
                            data: [{ x: SMC.e, y: SMC.edot }],
                            backgroundColor: '#fbbf24',
                            borderColor: '#fff',
                            pointRadius: 6
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    scales: {
                        x: {
                            title: { display: true, text: 'Error (e)' },
                            min: -10, max: 10,
                            grid: { color: gridColor }
                        },
                        y: {
                            title: { display: true, text: 'Error Rate (ƒó)' },
                            min: -10, max: 10,
                            grid: { color: gridColor }
                        }
                    }
                }
            });
        }

        function genLineData(lambda) {
            // Plot edot = -lambda * e
            // for e from -10 to 10
            return [
                { x: -10, y: -lambda * -10 },
                { x: 10, y: -lambda * 10 }
            ];
        }

        function updateSim() {
            const dt = 0.02;
            const res = SMC.update(dt);

            // Update Trajectory
            trajData.push({ x: SMC.e, y: SMC.edot });
            if (trajData.length > 200) trajData.shift();

            // Check reset condition if out of bounds
            if (Math.abs(SMC.e) > 20 || Math.abs(SMC.edot) > 20) {
                // Auto reset if unstable
                resetSim();
            }

            // Update Chart
            if (chart) {
                chart.data.datasets[1].data = trajData;
                chart.data.datasets[2].data = [{ x: SMC.e, y: SMC.edot }];
                // Update sliding line if lambda changed
                chart.data.datasets[0].data = genLineData(SMC.lambda);
                chart.update();
            }

            // Update UI
            document.getElementById('metricE').textContent = SMC.e.toFixed(3);
            document.getElementById('metricEdot').textContent = SMC.edot.toFixed(3);
            document.getElementById('metricS').textContent = res.s.toFixed(3);
        }

        function resetSim() {
            // Random start position
            const startX = (Math.random() > 0.5 ? 1 : -1) * (5 + Math.random() * 3);
            SMC.e = startX;
            SMC.edot = 0;
            trajData.length = 0;
        }

        // Sliders
        document.getElementById('sliderK').addEventListener('input', (e) => {
            SMC.K = parseFloat(e.target.value);
            document.getElementById('valK').textContent = SMC.K.toFixed(1);
        });

        document.getElementById('sliderLambda').addEventListener('input', (e) => {
            SMC.lambda = parseFloat(e.target.value);
            document.getElementById('valLambda').textContent = SMC.lambda.toFixed(1);
        });

        document.addEventListener('DOMContentLoaded', () => {
            initChart();
            timer = setInterval(updateSim, 20); // 50 Hz
        });
    </script>
</body>

</html>